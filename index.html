<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>相互位置・距離・方位・速度・COG（2台スマホ・WebRTC）</title>
<style>
:root { --bg:#0c1222; --fg:#e9eefc; --muted:#a9b6d3; --accent:#5aa9ff; --good:#2ec27e; --warn:#f6c177; --bad:#ff6b6b; --card:#111833; }
* { box-sizing:border-box; }
html,body { margin:0; background:var(--bg); color:var(--fg); font:15px/1.5 system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif; }
.container { max-width:1000px; margin:0 auto; padding:16px; }
h1 { font-size:1.1rem; margin:0 0 8px; }
h2 { font-size:1rem; margin:18px 0 8px; color:var(--muted); }
.card { background:var(--card); border:1px solid #1d2444; border-radius:14px; padding:12px; margin-top:12px; box-shadow:0 4px 20px rgba(0,0,0,.2); }
.row { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
@media (max-width: 760px){ .row { grid-template-columns: 1fr; } }
.kv { display:flex; justify-content:space-between; gap:8px; padding:8px 0; border-bottom:1px dashed #273056; }
.kv:last-child{ border-bottom:none; }
.k { color:var(--muted); }
.v { font-variant-numeric: tabular-nums; font-weight:600; }
.small { font-size:.85rem; color:var(--muted); }
input[type="text"], textarea { width:100%; background:#0b1127; color:var(--fg); border:1px solid #2a3566; border-radius:10px; padding:8px; font-family:inherit; }
textarea { min-height:120px; resize:vertical; }
button { background:var(--accent); color:#071120; border:none; border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer; }
button.secondary { background:#273056; color:var(--fg); }
button:disabled { opacity:.5; cursor:not-allowed; }
.grid-3 { display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; }
.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
hr.sep { border:none; border-top:1px solid #222b52; margin:10px 0; }
.badge { padding:2px 8px; border-radius:9999px; background:#203056; color:#9fc3ff; font-size:.75rem; }
.flex { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
.rangeBox{ display:flex; gap:8px; align-items:center; }
.output { white-space:pre-wrap; word-break:break-word; }
.footer { margin:18px 0 8px; color:#7d8db8; font-size:.85rem; }
</style>
</head>
<body>
<div class="container">
  <h1>2台のスマホでリアルタイム共有：緯度経度（DMS）・距離・方位・速度・COG</h1>
  <div class="small">HTTPSで開いてください（位置情報・WebRTCの要件）。両方の端末でこのページを開き、下の手順に従って接続します。</div>

  <div class="card">
    <h2>接続（コピー＆ペースト式 / WebRTC DataChannel）</h2>
    <ol class="small">
      <li><b>端末A</b>で［オファーを作成］→ 出力SDPをコピー。</li>
      <li><b>端末B</b>で AのSDPを「相手のSDP」に貼り、［アンサーを作成］→ BのSDPをコピー。</li>
      <li><b>端末A</b>で BのSDPを「相手のSDP」に貼り、［接続を確定］。</li>
    </ol>
    <div class="grid-3">
      <button id="btnOffer">オファーを作成</button>
      <button id="btnAnswer" disabled>アンサーを作成</button>
      <button id="btnFinish" disabled>接続を確定</button>
    </div>
    <div class="flex" style="margin-top:8px">
      <button id="btnCopyLocal" class="secondary" disabled>自分のSDPをコピー</button>
      <button id="btnPasteRemote" class="secondary">相手のSDPを貼る（クリップボード読込）</button>
    </div>
    <div class="row" style="margin-top:8px">
      <div>
        <div class="small">自分のSDP</div>
        <textarea id="localSDP" class="mono" readonly></textarea>
      </div>
      <div>
        <div class="small">相手のSDP</div>
        <textarea id="remoteSDP" class="mono" placeholder="ここに相手のSDPを貼る"></textarea>
      </div>
    </div>
    <div class="small" style="margin-top:8px">状態：<span id="connState" class="badge">未接続</span> / DataChannel：<span id="dcState" class="badge">-</span></div>
  </div>

  <div class="card">
    <h2>送信設定</h2>
    <div class="rangeBox">
      <label class="small">送信間隔：</label>
      <input type="range" id="txInterval" min="250" max="5000" step="250" value="1000">
      <span id="txLabel" class="small">1000 ms</span>
      <button id="btnApply" class="secondary">適用</button>
    </div>
    <div class="small">端末の最新測位を蓄え、指定間隔でまとめて送信します（watchPositionは高頻度）。</div>
  </div>

  <div class="row">
    <div class="card">
      <h2>自分（Local）<span id="myTs" class="small"></span></h2>
      <div class="kv"><div class="k">緯度</div><div class="v" id="myLat"></div></div>
      <div class="kv"><div class="k">経度</div><div class="v" id="myLon"></div></div>
      <div class="kv"><div class="k">速度</div><div class="v" id="mySpd"></div></div>
      <div class="kv"><div class="k">進行方向（COG）</div><div class="v" id="myCog"></div></div>
      <div class="kv"><div class="k">方位（ヘディング）</div><div class="v" id="myHead"></div></div>
      <div class="kv"><div class="k">生データ</div><div class="v small" id="myRaw"></div></div>
    </div>
    <div class="card">
      <h2>相手（Remote）<span id="peerTs" class="small"></span></h2>
      <div class="kv"><div class="k">緯度</div><div class="v" id="peerLat"></div></div>
      <div class="kv"><div class="k">経度</div><div class="v" id="peerLon"></div></div>
      <div class="kv"><div class="k">速度</div><div class="v" id="peerSpd"></div></div>
      <div class="kv"><div class="k">進行方向（COG）</div><div class="v" id="peerCog"></div></div>
      <div class="kv"><div class="k">方位（ヘディング）</div><div class="v" id="peerHead"></div></div>
      <div class="kv"><div class="k">生データ</div><div class="v small" id="peerRaw"></div></div>
    </div>
  </div>

  <div class="card">
    <h2>相対情報（自分→相手）</h2>
    <div class="kv"><div class="k">距離</div><div class="v" id="relDist"></div></div>
    <div class="kv"><div class="k">相手の方位（真方位）</div><div class="v" id="relBrg"></div></div>
  </div>

  <div class="footer">測位：<code>navigator.geolocation.watchPosition</code>（高精度）。計算：ハーサイン（距離）＋初期方位角。速度はm/s→knots, km/h。COGは <span class="small">heading→なければ直近2点の移動ベクトル</span>。</div>
</div>

<script>
(() => {
  // ---------- Utilities ----------
  const toFixed = (x, n=4) => (Number.isFinite(x) ? x.toFixed(n) : '—');

  function toDMS(deg, lat=true){
    if (!Number.isFinite(deg)) return '—';
    const abs = Math.abs(deg);
    const d = Math.floor(abs);
    const mFloat = (abs - d) * 60;
    const m = Math.floor(mFloat);
    const s = (mFloat - m) * 60;
    const hemi = lat ? (deg>=0 ? 'N' : 'S') : (deg>=0 ? 'E' : 'W');
    return `${d}°${m}′${s.toFixed(4)}″ ${hemi}`;
  }

  const toKnots = mps => Number.isFinite(mps) ? (mps * 1.943844492).toFixed(2) : '—';
  const toKmh   = mps => Number.isFinite(mps) ? (mps * 3.6).toFixed(2) : '—';

  // distance (m) & initial bearing (deg) between two lat/lon (deg)
  function distAndBearing(lat1, lon1, lat2, lon2){
    if (![lat1,lon1,lat2,lon2].every(Number.isFinite)) return {dist: NaN, brg: NaN};
    const R = 6371000; // meters
    const φ1 = lat1*Math.PI/180, φ2 = lat2*Math.PI/180;
    const Δφ = (lat2-lat1)*Math.PI/180;
    const Δλ = (lon2-lon1)*Math.PI/180;
    const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    const dist = R*c;
    const y = Math.sin(Δλ)*Math.cos(φ2);
    const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
    let θ = Math.atan2(y, x)*180/Math.PI;
    if (θ < 0) θ += 360;
    return {dist, brg: θ};
  }

  function clampDeg360(deg){
    if (!Number.isFinite(deg)) return NaN;
    deg = deg % 360;
    return deg < 0 ? deg + 360 : deg;
  }

  function tsStr(t){
    if (!t) return '';
    const d = new Date(t);
    const z = n => String(n).padStart(2,'0');
    return `（${d.getHours()}:${z(d.getMinutes())}:${z(d.getSeconds())}）`;
  }

  // ---------- DOM refs ----------
  const el = id => document.getElementById(id);
  const myLat = el('myLat'), myLon = el('myLon'), mySpd = el('mySpd'), myCog = el('myCog'), myHead = el('myHead'), myRaw = el('myRaw'), myTs = el('myTs');
  const peerLat = el('peerLat'), peerLon = el('peerLon'), peerSpd = el('peerSpd'), peerCog = el('peerCog'), peerHead = el('peerHead'), peerRaw = el('peerRaw'), peerTs = el('peerTs');
  const relDist = el('relDist'), relBrg = el('relBrg');
  const txInterval = el('txInterval'), txLabel = el('txLabel'), btnApply = el('btnApply');

  const btnOffer = el('btnOffer'), btnAnswer = el('btnAnswer'), btnFinish = el('btnFinish');
  const btnCopyLocal = el('btnCopyLocal'), btnPasteRemote = el('btnPasteRemote');
  const localSDP = el('localSDP'), remoteSDP = el('remoteSDP');
  const connState = el('connState'), dcState = el('dcState');

  // ---------- WebRTC ----------
  const pc = new RTCPeerConnection({
    iceServers: [{urls: 'stun:stun.l.google.com:19302'}]
  });
  let dc; // data channel
  let isOfferer = false;

  pc.onconnectionstatechange = () => {
    connState.textContent = pc.connectionState;
  };
  pc.onicegatheringstatechange = () => {
    // when complete, enable copy
    if (pc.iceGatheringState === 'complete') {
      localSDP.value = JSON.stringify(pc.localDescription);
      btnCopyLocal.disabled = false;
    }
  };
  pc.onicecandidate = e => {
    // trickle happens; keep textarea updated
    if (pc.localDescription) {
      localSDP.value = JSON.stringify(pc.localDescription);
    }
  };

  function setupDC(channel){
    dc = channel;
    dc.onopen = () => { dcState.textContent = 'open'; };
    dc.onclose = () => { dcState.textContent = 'closed'; };
    dc.onmessage = onDCMessage;
  }

  // Offerer creates channel
  btnOffer.onclick = async () => {
    isOfferer = true;
    setupDC(pc.createDataChannel('pos'));
    btnOffer.disabled = true;
    btnAnswer.disabled = false; // allow remote side flow as instruction aid
    try {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      // Wait for ICE to complete before enabling copy (handled in onicegatheringstatechange)
    } catch (e){ alert('Offer作成エラー: ' + e); }
  };

  // Answerer path
  btnAnswer.onclick = async () => {
    try {
      const remote = remoteSDP.value.trim();
      if (!remote) return alert('相手のSDPを貼ってください');
      await pc.setRemoteDescription(JSON.parse(remote));
      pc.ondatachannel = ev => setupDC(ev.channel);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      btnFinish.disabled = false;
    } catch (e){ alert('Answer作成エラー: ' + e); }
  };

  btnFinish.onclick = async () => {
    try {
      const remote = remoteSDP.value.trim();
      if (!remote) return alert('相手のSDPを貼ってください');
      await pc.setRemoteDescription(JSON.parse(remote));
      btnFinish.disabled = true;
    } catch (e){ alert('接続確定エラー: ' + e); }
  };

  btnCopyLocal.onclick = async () => {
    try {
      await navigator.clipboard.writeText(localSDP.value);
      btnCopyLocal.textContent = 'コピーしました';
      setTimeout(()=>btnCopyLocal.textContent='自分のSDPをコピー', 1200);
    } catch { /* ignore */ }
  };
  btnPasteRemote.onclick = async () => {
    try {
      const t = await navigator.clipboard.readText();
      if (t) remoteSDP.value = t;
    } catch { alert('クリップボードから読み取れませんでした'); }
  };

  // ---------- Geo ----------
  let lastLocalFix = null;   // {lat, lon, speed(m/s), heading(deg), cog(deg), t}
  let prevLocalPoint = null; // {lat, lon, t} for COG fallback
  let lastPeerFix = null;
  let txTimer = null;
  let txMs = Number(txInterval.value);

  function updateTxTimer(){
    if (txTimer) clearInterval(txTimer);
    txTimer = setInterval(()=> {
      if (dc && dc.readyState === 'open' && lastLocalFix){
        dc.send(JSON.stringify({type:'fix', payload:lastLocalFix}));
      }
    }, txMs);
  }
  updateTxTimer();

  txInterval.addEventListener('input', () => txLabel.textContent = `${txInterval.value} ms`);
  btnApply.addEventListener('click', () => {
    txMs = Number(txInterval.value);
    updateTxTimer();
    btnApply.textContent = '適用済み';
    setTimeout(()=>btnApply.textContent='適用', 1000);
  });

  function onPosition(pos){
    const { latitude:lat, longitude:lon, speed, heading } = pos.coords; // speed: m/s, heading: deg
    const t = pos.timestamp || Date.now();

    // Fallback COG from previous point if heading not available
    let cog = Number.isFinite(heading) ? clampDeg360(heading) : NaN;
    if (!Number.isFinite(cog) && prevLocalPoint){
      const { brg } = distAndBearing(prevLocalPoint.lat, prevLocalPoint.lon, lat, lon);
      if (Number.isFinite(brg)) cog = brg;
    }
    // prepare record
    lastLocalFix = {
      lat, lon,
      speed: Number.isFinite(speed) ? speed : NaN,
      heading: Number.isFinite(heading) ? clampDeg360(heading) : NaN,
      cog: Number.isFinite(cog) ? cog : NaN,
      t
    };
    // update prev point only if moved > ~3m to avoid jitter
    if (!prevLocalPoint || distAndBearing(prevLocalPoint.lat, prevLocalPoint.lon, lat, lon).dist > 3){
      prevLocalPoint = {lat, lon, t};
    }
    renderLocal();
    renderRelative();
  }

  function onError(err){
    alert('位置情報エラー: ' + err.message);
  }

  if ('geolocation' in navigator){
    navigator.geolocation.watchPosition(onPosition, onError, {
      enableHighAccuracy:true, maximumAge:1000, timeout:15000
    });
  } else {
    alert('この端末はGeolocationに対応していません');
  }

  // ---------- DC message ----------
  function onDCMessage(ev){
    try {
      const msg = JSON.parse(ev.data);
      if (msg.type === 'fix'){
        lastPeerFix = msg.payload;
        renderPeer();
        renderRelative();
      }
    } catch(e){ /* ignore non-JSON */ }
  }

  // ---------- Rendering ----------
  function renderLocal(){
    const d = lastLocalFix || {};
    myLat.textContent = toDMS(d.lat, true);
    myLon.textContent = toDMS(d.lon, false);
    mySpd.textContent = Number.isFinite(d.speed) ? `${toKnots(d.speed)} kn / ${toKmh(d.speed)} km/h` : '—';
    myCog.textContent = Number.isFinite(d.cog) ? `${d.cog.toFixed(1)} °` : '—';
    myHead.textContent = Number.isFinite(d.heading) ? `${d.heading.toFixed(1)} °` : '—';
    myRaw.textContent = JSON.stringify(d);
    myTs.textContent = tsStr(d.t);
  }

  function renderPeer(){
    const d = lastPeerFix || {};
    peerLat.textContent = toDMS(d.lat, true);
    peerLon.textContent = toDMS(d.lon, false);
    peerSpd.textContent = Number.isFinite(d.speed) ? `${toKnots(d.speed)} kn / ${toKmh(d.speed)} km/h` : '—';
    peerCog.textContent = Number.isFinite(d.cog) ? `${d.cog.toFixed(1)} °` : '—';
    peerHead.textContent = Number.isFinite(d.heading) ? `${d.heading.toFixed(1)} °` : '—';
    peerRaw.textContent = JSON.stringify(d);
    peerTs.textContent = tsStr(d.t);
  }

  function renderRelative(){
    if (!(lastLocalFix && lastPeerFix)){
      relDist.textContent = '—';
      relBrg.textContent = '—';
      return;
    }
    const { dist, brg } = distAndBearing(lastLocalFix.lat, lastLocalFix.lon, lastPeerFix.lat, lastPeerFix.lon);
    relDist.textContent = Number.isFinite(dist) ? `${dist.toFixed(1)} m` : '—';
    relBrg.textContent = Number.isFinite(brg) ? `${brg.toFixed(1)} °` : '—';
  }

})();
</script>
</body>
</html>
