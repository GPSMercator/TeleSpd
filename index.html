<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Peer GPS (2 phones)</title>
<style>
  :root{--bg:#0b1020;--panel:#131a33;--ink:#e8eefc;--muted:#9fb2d8;--accent:#5aa9ff;--good:#2ec27e;--warn:#f6c177;--bad:#ff6b6b}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:15px/1.4 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Noto Sans JP",sans-serif}
  .wrap{max-width:980px;margin:0 auto;padding:14px}
  h1{font-size:1.2rem;margin:4px 0 12px}
  .grid{display:grid;grid-template-columns:1fr;gap:10px}
  @media (min-width:860px){.grid{grid-template-columns:1.1fr .9fr}}
  .card{background:var(--panel);border-radius:16px;box-shadow:0 8px 28px rgba(0,0,0,.25);padding:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .row > *{flex:1}
  label{font-weight:600;color:var(--muted);font-size:.9rem}
  input,textarea,button,select{width:100%;box-sizing:border-box;background:#0e1530;color:var(--ink);border:1px solid #26315e;border-radius:10px;padding:10px 12px}
  textarea{min-height:120px;resize:vertical}
  button{cursor:pointer;border:1px solid #3a4ea3;background:linear-gradient(180deg,#1a2560,#141d49);font-weight:700}
  button.primary{background:linear-gradient(180deg,#3170ff,#2651cc)}
  button.good{border-color:#1e5e3a;background:linear-gradient(180deg,#2ec27e,#1f8e5c)}
  button.warn{border-color:#7a5c1a;background:linear-gradient(180deg,#f6c177,#c0923f)}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  .stat{display:grid;grid-template-columns:auto 1fr;gap:6px 10px}
  .stat div:nth-child(odd){color:var(--muted)}
  .big{font-size:1.25rem;font-weight:800}
  .ok{color:var(--good)}
  .err{color:var(--bad)}
  .muted{color:var(--muted)}
  .footer{opacity:.7;text-align:center;margin-top:16px;font-size:.85rem}
  /* modal */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;padding:20px;z-index:9999}
  .modal .box{background:#0f1736;border:1px solid #2b3a7e;border-radius:18px;max-width:92vw;width:560px;padding:14px;box-shadow:0 12px 32px rgba(0,0,0,.45)}
  .modal .box h3{margin:6px 0 10px;font-size:1rem;color:var(--ink)}
  .modal .grid2{display:grid;grid-template-columns:1fr;gap:10px}
  .modal .bar{display:flex;gap:10px;align-items:center}
  .modal .bar > *{flex:1}
  .center{display:flex;align-items:center;justify-content:center}
  canvas#qrCanvas{width:100%;height:auto;background:#fff;border-radius:10px}
  video#qrVideo{width:100%;max-height:60vh;background:#000;border-radius:10px}
</style>
</head>
<body>
<div class="wrap">
  <h1>Peer GPS – 二台のスマホで相互位置・距離・方位・速度・COG をリアルタイム共有</h1>
  <div class="grid">
    <section class="card" id="connect">
      <h2>1) 接続 (WebRTC)</h2>
      <p class="muted">同じページを二台で開き、どちらかが <b>オファ生成</b> → もう一方が <b>オファ貼付→アンサー生成</b> → 最初の端末に <b>アンサー貼付</b> の順に進めます（いまは <b>QR</b> で交換できます）。</p>
      <div class="row">
        <button id="btnMakeOffer" class="primary">オファ生成</button>
        <button id="btnMakeAnswer">オファ貼付 → アンサー生成</button>
        <button id="btnApplyAnswer" class="good">アンサー貼付（接続完了）</button>
      </div>
      <div class="row">
        <div>
          <label for="offer">オファ SDP</label>
          <textarea id="offer" class="mono" placeholder="ここに自動生成／または相手のオファを貼付"></textarea>
          <div class="row">
            <button id="btnOfferQRShow">オファをQR表示</button>
            <button id="btnOfferQRScan" class="good">オファQR読取 → 自動貼付</button>
          </div>
        </div>
        <div>
          <label for="answer">アンサー SDP</label>
          <textarea id="answer" class="mono" placeholder="ここにアンサーを貼付（自動生成後）"></textarea>
          <div class="row">
            <button id="btnAnswerQRShow">アンサーをQR表示</button>
            <button id="btnAnswerQRScan" class="good">アンサーQR読取 → 自動貼付</button>
          </div>
        </div>
      </div>
      <p id="connState" class="muted">未接続</p>
    </section>

    <section class="card" id="loc">
      <h2>2) 位置共有</h2>
      <div class="row">
        <div><button id="btnStartShare" class="good">位置共有開始</button></div>
        <div><button id="btnStopShare" class="warn">停止</button></div>
        <div>
          <label for="hz">送信間隔 (ms)</label>
          <input id="hz" type="number" min="250" step="250" value="1000" />
        </div>
        <div>
          <label><input id="hiacc" type="checkbox" checked /> 高精度 (GPS優先)</label>
        </div>
      </div>
      <div class="row">
        <div>
          <label>自分 (Self)</label>
          <div class="stat">
            <div>緯度 / 経度</div><div id="selfLatLon" class="big">–</div>
            <div>速度</div><div id="selfSpd">–</div>
            <div>COG</div><div id="selfCog">–</div>
            <div>時刻</div><div id="selfTs">–</div>
          </div>
        </div>
        <div>
          <label>相手 (Peer)</label>
          <div class="stat">
            <div>緯度 / 経度</div><div id="peerLatLon" class="big">–</div>
            <div>速度</div><div id="peerSpd">–</div>
            <div>COG</div><div id="peerCog">–</div>
            <div>時刻</div><div id="peerTs">–</div>
          </div>
        </div>
      </div>
      <hr style="border-color:#26315e;border-style:solid;border-width:1px 0 0;margin:12px 0">
      <div class="row">
        <div>
          <label>相対情報 (Self → Peer)</label>
          <div class="stat">
            <div>距離</div><div id="rangeMeters" class="big">–</div>
            <div>方位</div><div id="bearing" class="big">–</div>
          </div>
        </div>
        <div>
          <label>状態</label>
          <div class="stat">
            <div>接続</div><div id="iceState">–</div>
            <div>データチャネル</div><div id="dcState">–</div>
            <div>位置共有</div><div id="gpsState">–</div>
          </div>
        </div>
      </div>
    </section>
  </div>
  <p class="footer">速度: m/s → kn, km/h に換算。COG: 進行方向 (0–360°)。方位: 自分→相手の方位 (0–360°)。DMS: 度°分′秒″。</p>
</div>

<!-- QR モーダル -->
<div class="modal" id="qrModal">
  <div class="box">
    <div class="bar">
      <h3 id="qrTitle">QR</h3>
      <button id="qrClose">閉じる</button>
    </div>
    <div id="qrGen" class="grid2" style="display:none">
      <div class="center"><canvas id="qrCanvas" width="512" height="512"></canvas></div>
      <textarea id="qrText" class="mono" readonly></textarea>
    </div>
    <div id="qrScan" class="grid2" style="display:none">
      <video id="qrVideo" playsinline></video>
      <div class="row"><button id="qrScanStop" class="warn">読み取り停止</button></div>
      <p class="muted" id="qrScanHint">カメラにQRを映してください。BarcodeDetector非対応端末ではこの機能は使えません（その場合はテキスト貼付をご利用ください）。</p>
    </div>
  </div>
</div>

<script>
// ---- helpers ----
const toDMS = (deg, ns='NS') => {
  const d = Math.floor(Math.abs(deg));
  const minFloat = (Math.abs(deg) - d) * 60;
  const m = Math.floor(minFloat);
  const sec = (minFloat - m) * 60;
  const hemi = deg >= 0 ? ns[0] : ns[1];
  return `${d}°${m.toString().padStart(2,'0')}′${sec.toFixed(2).padStart(5,'0')}″ ${hemi}`;
};
const fmtLatLonDMS = (lat, lon) => `${toDMS(lat,'NS')}  /  ${toDMS(lon,'EW')}`;
const toKnots = ms => ms * 1.9438444924574;
const toKmh = ms => ms * 3.6;
const clamp360 = deg => ((deg % 360) + 360) % 360;
const haversine = (a,b) => { // meters
  const R = 6371008.8;
  const toRad = x => x*Math.PI/180;
  const dLat = toRad(b.lat - a.lat);
  const dLon = toRad(b.lon - a.lon);
  const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
  const sinDLat = Math.sin(dLat/2), sinDLon = Math.sin(dLon/2);
  const h = sinDLat*sinDLat + Math.cos(lat1)*Math.cos(lat2)*sinDLon*sinDLon;
  return 2*R*Math.asin(Math.min(1, Math.sqrt(h)));
};
const bearingTo = (a,b) => { // degrees 0..360 from a -> b
  const toRad = x => x*Math.PI/180, toDeg = x => x*180/Math.PI;
  const lat1 = toRad(a.lat), lat2 = toRad(b.lat); const dLon = toRad(b.lon - a.lon);
  const y = Math.sin(dLon) * Math.cos(lat2);
  const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
  return clamp360(toDeg(Math.atan2(y,x)));
};

// ---- UI refs ----
const el = id => document.getElementById(id);
const ui = {
  offer: el('offer'), answer: el('answer'),
  connState: el('connState'), iceState: el('iceState'), dcState: el('dcState'), gpsState: el('gpsState'),
  selfLatLon: el('selfLatLon'), selfSpd: el('selfSpd'), selfCog: el('selfCog'), selfTs: el('selfTs'),
  peerLatLon: el('peerLatLon'), peerSpd: el('peerSpd'), peerCog: el('peerCog'), peerTs: el('peerTs'),
  rangeMeters: el('rangeMeters'), bearing: el('bearing'),
  hiacc: el('hiacc'), hz: el('hz'),
  // QR
  modal: el('qrModal'), qrTitle: el('qrTitle'), qrCanvas: el('qrCanvas'), qrText: el('qrText'),
  qrGen: el('qrGen'), qrScan: el('qrScan'), qrVideo: el('qrVideo'), qrScanHint: el('qrScanHint')
};

// ---- state ----
let pc, dc; // RTCPeerConnection & DataChannel
let watchId = null; // geolocation watch
let lastSelfPos = null; // for COG fallback
let self = {lat:null, lon:null, spd:null, cog:null, ts:null};
let peer = {lat:null, lon:null, spd:null, cog:null, ts:null};

// ---- WebRTC setup ----
const stunServers = [{ urls: [ 'stun:stun.l.google.com:19302', 'stun:stun1.l.google.com:19302' ] }];

function ensurePC() {
  if (pc) return pc;
  pc = new RTCPeerConnection({ iceServers: stunServers });
  pc.onicegatheringstatechange = () => {
    ui.connState.textContent = `ICE収集: ${pc.iceGatheringState}`;
    if (pc.iceGatheringState === 'complete') {
      if (pc.localDescription?.type === 'offer') ui.offer.value = JSON.stringify(pc.localDescription);
      if (pc.localDescription?.type === 'answer') ui.answer.value = JSON.stringify(pc.localDescription);
    }
  };
  pc.onconnectionstatechange = () => {
    ui.connState.textContent = `接続: ${pc.connectionState}`;
  };
  pc.oniceconnectionstatechange = () => {
    ui.iceState.textContent = pc.iceConnectionState;
  };
  pc.ondatachannel = (ev) => {
    dc = ev.channel; bindDC();
  };
  return pc;
}

function bindDC(){
  if (!dc) return;
  ui.dcState.textContent = `DC: ${dc.readyState}`;
  dc.onopen = () => ui.dcState.textContent = '開';
  dc.onclose = () => ui.dcState.textContent = '閉';
  dc.onerror = (e) => ui.dcState.textContent = 'エラー';
  dc.onmessage = (ev) => {
    try{
      const msg = JSON.parse(ev.data);
      if (msg.type === 'pos') {
        peer = msg.payload; peer.ts = msg.ts; updatePeerUI(); updateRelative();
      }
    }catch(e){/* ignore */}
  };
}

async function makeOffer(){
  ensurePC();
  dc = pc.createDataChannel('pos');
  bindDC();
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  ui.offer.value = JSON.stringify(pc.localDescription);
}

async function makeAnswer(){
  ensurePC();
  const offer = JSON.parse(ui.offer.value);
  await pc.setRemoteDescription(offer);
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  ui.answer.value = JSON.stringify(pc.localDescription);
}

async function applyAnswer(){
  const answer = JSON.parse(ui.answer.value);
  await pc.setRemoteDescription(answer);
}

// ---- Position sharing ----
function startShare(){
  if (!('geolocation' in navigator)) { ui.gpsState.textContent = '非対応'; return; }
  const opts = { enableHighAccuracy: ui.hiacc.checked, maximumAge: 0, timeout: 20000 };
  if (watchId) navigator.geolocation.clearWatch(watchId);
  lastSelfPos = null;
  watchId = navigator.geolocation.watchPosition(onPos, onPosErr, opts);
  ui.gpsState.textContent = '監視中';
}
function stopShare(){
  if (watchId) navigator.geolocation.clearWatch(watchId);
  watchId = null; ui.gpsState.textContent = '停止';
}
function onPosErr(err){ ui.gpsState.textContent = `エラー: ${err.code} ${err.message}`; }

let lastSend = 0;
function onPos(pos){
  const c = pos.coords; const now = Date.now();
  const lat = c.latitude, lon = c.longitude;
  let spd = (typeof c.speed === 'number' && c.speed >= 0) ? c.speed : null; 
  let cog = (typeof c.heading === 'number' && c.heading >= 0) ? c.heading : null;
  const thisPoint = {lat, lon};
  if (!spd || !cog) {
    if (lastSelfPos && (now - lastSelfPos.ts) > 400) {
      const dt = (now - lastSelfPos.ts)/1000;
      const dist = haversine(lastSelfPos, thisPoint);
      const brg = bearingTo(lastSelfPos, thisPoint);
      if (!spd) spd = dist/dt;
      if (!cog && dist > 1) cog = brg;
    }
    lastSelfPos = {...thisPoint, ts: now};
  }
  self = { lat, lon, spd, cog, ts: now };
  updateSelfUI();
  const period = Math.max(250, Number(ui.hz.value)||1000);
  if (dc && dc.readyState === 'open' && now - lastSend >= period) {
    dc.send(JSON.stringify({ type:'pos', ts: now, payload: self }));
    lastSend = now;
  }
  updateRelative();
}

function updateSelfUI(){
  if (self.lat!=null) ui.selfLatLon.textContent = fmtLatLonDMS(self.lat, self.lon);
  ui.selfSpd.textContent = self.spd!=null ? `${self.spd.toFixed(2)} m/s  |  ${toKnots(self.spd).toFixed(2)} kn  |  ${toKmh(self.spd).toFixed(1)} km/h` : '–';
  ui.selfCog.textContent = self.cog!=null ? `${self.cog.toFixed(0)}°` : '–';
  ui.selfTs.textContent = self.ts? new Date(self.ts).toLocaleTimeString() : '–';
}
function updatePeerUI(){
  if (peer.lat!=null) ui.peerLatLon.textContent = fmtLatLonDMS(peer.lat, peer.lon);
  ui.peerSpd.textContent = peer.spd!=null ? `${peer.spd.toFixed(2)} m/s  |  ${toKnots(peer.spd).toFixed(2)} kn  |  ${toKmh(peer.spd).toFixed(1)} km/h` : '–';
  ui.peerCog.textContent = peer.cog!=null ? `${peer.cog.toFixed(0)}°` : '–';
  ui.peerTs.textContent = peer.ts? new Date(peer.ts).toLocaleTimeString() : '–';
}
function updateRelative(){
  if (self.lat==null || peer.lat==null) return;
  const R = haversine(self, peer);
  const B = bearingTo(self, peer);
  ui.rangeMeters.textContent = `${R.toFixed(R<1000?1:0)} m`;
  ui.bearing.textContent = `${B.toFixed(0)}°`;
}

// ---- QR: generate & scan ----
function openModal(mode, title){
  ui.qrTitle.textContent = title; ui.modal.style.display='flex';
  ui.qrGen.style.display = (mode==='gen')?'block':'none';
  ui.qrScan.style.display = (mode==='scan')?'block':'none';
}
function closeModal(){ ui.modal.style.display='none'; stopScan(); }

// Minimal QR generator (v1.., auto) using Kazuhiko Arase's qrcode-generator (MIT) trimmed
// source: https://github.com/kazuhikoarase/qrcode-generator (embedded, trimmed for QRCode, QR8bitByte)
(function(){
  function QR8bitByte(data){this.mode=1;this.data=data;}
  QR8bitByte.prototype={getLength:function(){return this.data.length},write:function(buffer){for(var i=0;i<this.data.length;i++){buffer.put(this.data.charCodeAt(i),8)}}};
  function QRMath(){}
  QRMath.glog=function(n){if(n<1) throw new Error('glog '+n);return QRMath.LOG_TABLE[n]};
  QRMath.gexp=function(n){while(n<0)n+=255;while(n>=256)n-=255;return QRMath.EXP_TABLE[n]};
  QRMath.EXP_TABLE=new Array(256);QRMath.LOG_TABLE=new Array(256);for(var i=0;i<8;i++)QRMath.EXP_TABLE[i]=1<<i;for(i=8;i<256;i++)QRMath.EXP_TABLE[i]=QRMath.EXP_TABLE[i-4]^QRMath.EXP_TABLE[i-5]^QRMath.EXP_TABLE[i-6]^QRMath.EXP_TABLE[i-8];for(i=0;i<256;i++)QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]]=i;
  function QRPolynomial(nums, shift){var offset=0;while(offset<nums.length&&nums[offset]==0)offset++;this.num=new Array(nums.length-offset+shift);for(var i=0;i<nums.length-offset;i++)this.num[i]=nums[i+offset];}
  QRPolynomial.prototype={get:function(i){return this.num[i]},getLength:function(){return this.num.length},multiply:function(e){var num=new Array(this.getLength()+e.getLength()-1);for(var i=0;i<this.getLength();i++)for(var j=0;j<e.getLength();j++)num[i+j]^=QRMath.gexp(QRMath.glog(this.get(i))+QRMath.glog(e.get(j)));return new QRPolynomial(num,0)},mod:function(e){if(this.getLength()-e.getLength()<0)return this;var ratio=QRMath.glog(this.get(0))-QRMath.glog(e.get(0));var num=new Array(this.getLength());for(var i=0;i<this.getLength();i++)num[i]=this.get(i);for(i=0;i<e.getLength();i++)num[i]^=QRMath.gexp(QRMath.glog(e.get(i))+ratio);return new QRPolynomial(num,0).mod(e)}};
  var QRMode={MODE_8BIT_BYTE:1},QRErrorCorrectLevel={L:1,M:0,Q:3,H:2};
  var QRMaskPattern={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7};
  function QRUtil(){}
  QRUtil.PATTERN_POSITION_TABLE=[[],[6,18],[6,22],[6,26],[6,30]]; // up to ver 5 is enough for SDP text
  QRUtil.G15=(1<<10)|(1<<8)|(1<<5)|(1<<4)|(1<<2)|(1<<1)|(1);
  QRUtil.G18=(1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8)|(1<<5)|(1<<2)|(1);
  QRUtil.G15_MASK=(1<<14)|(1<<12)|(1<<10)|(1<<4)|(1<<1);
  QRUtil.getBCHTypeInfo=function(data){var d=data<<10;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)>=0){d^=(QRUtil.G15<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)));}return((data<<10)|d)^QRUtil.G15_MASK};
  QRUtil.getBCHDigit=function(data){var digit=0;while(data!=0){digit++;data>>>=1;}return digit};
  QRUtil.getMask=function(maskPattern,i,j){switch(maskPattern){case QRMaskPattern.PATTERN000:return (i+j)%2==0;case QRMaskPattern.PATTERN001:return i%2==0;case QRMaskPattern.PATTERN010:return j%3==0;case QRMaskPattern.PATTERN011:return (i+j)%3==0;case QRMaskPattern.PATTERN100:return (Math.floor(i/2)+Math.floor(j/3))%2==0;case QRMaskPattern.PATTERN101:return (i*j)%2+(i*j)%3==0;case QRMaskPattern.PATTERN110:return ((i*j)%3+(i+j)%2)==0;case QRMaskPattern.PATTERN111:return ((i*j)%3+(i+j)%3)==0;default:throw new Error('bad maskPattern')}};
  function QRBitBuffer(){this.buffer=[];this.length=0;}
  QRBitBuffer.prototype={get:function(i){return ((this.buffer[Math.floor(i/8)]>>> (7-i%8))&1)==1},put:function(num,length){for(var i=0;i<length;i++)this.putBit(((num>>> (length-i-1))&1)==1)},putBit:function(bit){if(this.length==this.buffer.length*8)this.buffer.push(0);if(bit)this.buffer[this.length>>>3]|=(0x80>>> (this.length%8));this.length++}};
  function QRRSBlock(totalCount,dataCount){this.totalCount=totalCount;this.dataCount=dataCount}
  QRRSBlock.getRSBlocks=function(typeNumber,errorCorrectLevel){ // simplified for typeNumber 1..10
    var rsBlock=[[1,19,7],[1,34,10],[1,55,15],[1,80,20],[1,108,26],[2,68,18],[2,78,20],[2,97,24],[2,116,30],[2,68,18]]; // total,data
    var r=rsBlock[typeNumber-1];return [new QRRSBlock(r[1],r[1]-r[2])];
  };
  function QRCode(typeNumber,errorCorrectLevel){this.typeNumber=typeNumber;this.errorCorrectLevel=errorCorrectLevel;this.modules=null;this.moduleCount=0;this.dataList=[]}
  QRCode.prototype={addData:function(data){this.dataList.push(new QR8bitByte(data))},isDark:function(row,col){if(this.modules[row][col]!=null)return this.modules[row][col];return false},getModuleCount:function(){return this.moduleCount},make:function(){this.makeImpl(false, QRMaskPattern.PATTERN101)},makeImpl:function(test,maskPattern){this.moduleCount=this.typeNumber*4+17;this.modules=new Array(this.moduleCount);for(var row=0;row<this.moduleCount;row++){this.modules[row]=new Array(this.moduleCount);for(var col=0;col<this.moduleCount;col++){this.modules[row][col]=null}};this.setupPositionProbePattern(0,0);this.setupPositionProbePattern(this.moduleCount-7,0);this.setupPositionProbePattern(0,this.moduleCount-7);this.setupTimingPattern();if(this.typeNumber>=2)this.setupPositionAdjustPattern();this.mapData(this.createData(),maskPattern)},setupPositionProbePattern:function(row,col){for(var r=-1;r<=7;r++){if(row+r<=-1||this.moduleCount<=row+r)continue;for(var c=-1;c<=7;c++){if(col+c<=-1||this.moduleCount<=col+c)continue;this.modules[row+r][col+c]=(r>=0&&r<=6&&(c==0||c==6))||(c>=0&&c<=6&&(r==0||r==6))||(r>=2&&r<=4&&c>=2&&c<=4)}}},setupTimingPattern:function(){for(var i=0;i<this.moduleCount;i++){if(this.modules[i][6]!=null)this.modules[i][6]=this.modules[i][6];else this.modules[i][6]=(i%2==0);if(this.modules[6][i]!=null)this.modules[6][i]=this.modules[6][i];else this.modules[6][i]=(i%2==0)}},setupPositionAdjustPattern:function(){var pos=QRUtil.PATTERN_POSITION_TABLE[this.typeNumber-1]||[];for(var i=0;i<pos.length;i++){for(var j=0;j<pos.length;j++){var row=pos[i],col=pos[j];if(this.modules[row][col]!=null)continue;for(var r=-2;r<=2;r++)for(var c=-2;c<=2;c++)this.modules[row+r][col+c]=(r==-2||r==2||c==-2||c==2)||(r==0&&c==0)}}},createData:function(){var buffer=new QRBitBuffer();for(var i=0;i<this.dataList.length;i++){var data=this.dataList[i];buffer.put(4,4);buffer.put(data.getLength(),8);data.write(buffer)};var rsBlocks=QRRSBlock.getRSBlocks(this.typeNumber,this.errorCorrectLevel);var totalDataCount=rsBlocks[0].dataCount;var bytes=[];for(i=0;i<totalDataCount&&i<Math.ceil(buffer.length/8);i++)bytes.push(255&(buffer.buffer[i]||0));return bytes},mapData:function(data,maskPattern){var inc=-1,row=this.moduleCount-1,bitIndex=7,byteIndex=0;for(var col=this.moduleCount-1;col>0;col-=2){if(col==6)col--;while(true){for(var c=0;c<2;c++){if(this.modules[row][col-c]==null){var dark=false;if(byteIndex<data.length){dark=((data[byteIndex]>>>bitIndex)&1)==1;}var mask=QRUtil.getMask(maskPattern,row,col-c);this.modules[row][col-c]=mask? !dark : dark;bitIndex--;if(bitIndex==-1){byteIndex++;bitIndex=7}}}row+=inc;if(row<0||this.moduleCount<=row){row-=inc;inc=-inc;break}}}},
  };
  window.__MiniQR = { QRCode: QRCode, QRErrorCorrectLevel: QRErrorCorrectLevel };
})();

function drawQR(text){
  // SDPは長いのでバイトを短縮: JSON文字列 → 圧縮なしのまま (必要ならLZベース64に拡張可)
  // 大きくなる場合は typeNumber を上げる
  const type = Math.min(10, Math.max(1, Math.ceil(text.length/20))); // 粗い目安
  const qr = new __MiniQR.QRCode(type, __MiniQR.QRErrorCorrectLevel.M);
  qr.addData(text); qr.make();
  const count = qr.getModuleCount();
  const scale = Math.floor(Math.min(ui.qrCanvas.width, ui.qrCanvas.height) / (count + 8));
  const size = (count + 8) * scale; // quiet-zone 4
  const ctx = ui.qrCanvas.getContext('2d');
  ctx.clearRect(0,0,ui.qrCanvas.width, ui.qrCanvas.height);
  // center
  const ox = Math.floor((ui.qrCanvas.width - size)/2);
  const oy = Math.floor((ui.qrCanvas.height - size)/2);
  ctx.fillStyle = '#fff'; ctx.fillRect(ox, oy, size, size);
  ctx.fillStyle = '#000';
  for (let r=0;r<count;r++){
    for (let c=0;c<count;c++){
      if (qr.isDark(r,c)) ctx.fillRect(ox + (c+4)*scale, oy + (r+4)*scale, scale, scale);
    }
  }
}

function showOfferQR(){
  if(!ui.offer.value){ alert('先に「オファ生成」を押してください'); return; }
  ui.qrText.value = ui.offer.value; drawQR(ui.offer.value); openModal('gen','オファQR');
}
function showAnswerQR(){
  if(!ui.answer.value){ alert('先に「アンサー生成」または相手のオファから生成してください'); return; }
  ui.qrText.value = ui.answer.value; drawQR(ui.answer.value); openModal('gen','アンサーQR');
}

let mediaStream=null, barcodeDetector=null, scanTimer=null, scanTarget='offer';
async function startScan(target){
  scanTarget = target; openModal('scan', target==='offer'?'オファQR読取':'アンサーQR読取');
  try{
    if ('BarcodeDetector' in window){
      const formats = await BarcodeDetector.getSupportedFormats();
      if (!formats.includes('qr_code')) throw new Error('BarcodeDetectorにqr_code未対応');
      barcodeDetector = new BarcodeDetector({ formats: ['qr_code'] });
    } else { throw new Error('BarcodeDetector未対応'); }
  }catch(e){ ui.qrScanHint.textContent = 'この端末はBarcodeDetectorに未対応です。すみませんが手動でテキスト貼付をご利用ください。'; return; }
  mediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
  ui.qrVideo.srcObject = mediaStream; await ui.qrVideo.play();
  const loop = async()=>{
    if (!barcodeDetector) return;
    try{
      const codes = await barcodeDetector.detect(ui.qrVideo);
      if (codes && codes.length){
        const txt = codes[0].rawValue.trim();
        if (scanTarget==='offer'){ ui.offer.value = txt; } else { ui.answer.value = txt; }
        closeModal();
        if (scanTarget==='offer'){ makeAnswer(); } // 自動アンサー生成
        return;
      }
    }catch(err){}
    scanTimer = requestAnimationFrame(loop);
  };
  loop();
}
function stopScan(){
  if (scanTimer) cancelAnimationFrame(scanTimer); scanTimer=null;
  if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
  barcodeDetector=null;
}

// ---- wire buttons ----
addEventListener('click', (e)=>{
  if (e.target.id==='btnMakeOffer') makeOffer();
  if (e.target.id==='btnMakeAnswer') makeAnswer();
  if (e.target.id==='btnApplyAnswer') applyAnswer();
  if (e.target.id==='btnStartShare') startShare();
  if (e.target.id==='btnStopShare') stopShare();
  if (e.target.id==='btnOfferQRShow') showOfferQR();
  if (e.target.id==='btnAnswerQRShow') showAnswerQR();
  if (e.target.id==='btnOfferQRScan') startScan('offer');
  if (e.target.id==='btnAnswerQRScan') startScan('answer');
  if (e.target.id==='qrClose') closeModal();
  if (e.target.id==='qrScanStop') closeModal();
});

</script>
</body>
</html>
